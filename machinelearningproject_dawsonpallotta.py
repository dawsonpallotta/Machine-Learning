# -*- coding: utf-8 -*-
"""MachineLearningProject_DawsonPallotta.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16q420opVGzly-ypPJHZCKN4MpDWstRC4

# Dawson Pallotta - Machine Learning Project

## Package instilation and importing
"""

import pandas as pd
import sklearn
import numpy as np
import matplotlib
import plotly
import seaborn
import keras
# import pytorch
import tensorflow as tf
import statsmodels
import yfinance as yf
import datetime as dt
from pandas_datareader import data as pdr
import mplfinance as mpf
import plotly.graph_objects as go
import xgboost as xgb
from sklearn.metrics import mean_squared_error
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
import matplotlib.pyplot as plt
from tensorflow.keras.layers import LSTM, Dense, Dropout
from sklearn.metrics import mean_absolute_error, mean_squared_error
import matplotlib.pyplot as plt
import math
from prophet import Prophet

"""## Model creation

### Energy Sector Models

#### ARIMA
"""

import yfinance as yf
import pandas as pd
from statsmodels.tsa.arima.model import ARIMA
import matplotlib.pyplot as plt
import numpy as np

# Function to create a differenced series to make the data stationary
def difference(dataset, interval=1):
    diff = list()
    for i in range(interval, len(dataset)):
        value = dataset[i] - dataset[i - interval]
        diff.append(value)
    return np.array(diff)

# Function to invert differenced value
def inverse_difference(history, yhat, interval=1):
    return yhat + history[-interval]

# List of tickers
tickers = ["XOM", "CVX", "COP"]

# Loop through each ticker
for ticker in tickers:
    # Download historical data for each ticker
    historical_data = yf.download(ticker, start="2010-01-01", end="2024-01-01")
    data = yf.download(ticker, start="2010-01-01", end="2022-01-01")
    close_prices = data['Close'].values

    # Assuming yearly differencing might be needed
    days_in_year = 365
    differenced = difference(close_prices, days_in_year)

    # Fit ARIMA model on the differenced data
    model = ARIMA(differenced, order=(1,1,1))
    model_fit = model.fit()

    # Forecast for the next two years (2022 to 2024)
    forecast = model_fit.forecast(steps=2*365)  # daily data

    # Invert the differenced forecast to something usable
    history = list(close_prices)
    predictions = []
    day = 1
    for yhat in forecast:
        inverted = inverse_difference(history, yhat, days_in_year)
        predictions.append(inverted)
        history.append(inverted)
        day += 1

    # Plotting the results for historical closing prices and forecasts
    plt.figure(figsize=(12, 6))
    plt.plot(historical_data.index, historical_data['Close'], label='Historical Closing Prices')
    forecast_index = pd.date_range(start='2022-01-01', periods=730, freq='D')
    plt.plot(forecast_index, predictions, color='red', label='Forecasted Closing Prices')
    plt.title(f'{ticker} ARIMA Forecast of Future Stock Prices')
    plt.xlabel('Date')
    plt.ylabel('Stock Price')
    plt.legend()
    plt.show()

    # Plotting actual prices and predicted prices
    plt.figure(figsize=(12, 6))
    plt.plot(historical_data.loc['2022-01-01':].index, historical_data.loc['2022-01-01':]['Close'], label='Actual Prices', color='blue')
    plt.plot(forecast_index, predictions, label='Predicted Prices', color='orange')
    plt.legend()
    plt.title(f"{ticker} Stock Price Prediction with ARIMA")
    plt.xlabel("Date")
    plt.ylabel("Price")
    plt.show()

import yfinance as yf
import pandas as pd
from statsmodels.tsa.arima.model import ARIMA
import matplotlib.pyplot as plt
import numpy as np

# Function to create a differenced series to make the data stationary
def difference(dataset, interval=1):
    diff = list()
    for i in range(interval, len(dataset)):
        value = dataset[i] - dataset[i - interval]
        diff.append(value)
    return np.array(diff)

# Function to invert differenced value
def inverse_difference(history, yhat, interval=1):
    return yhat + history[-interval]

# Function to calculate the average margin of difference between actual and predicted prices
def average_margin_of_difference(actual, predicted):
    margins = actual.values - predicted
    avg_margin = np.mean(np.abs(margins))
    return avg_margin

# Function to calculate the average margin of difference as a percentage
def average_margin_of_difference_percentage(actual, predicted):
    margins = actual.values - predicted
    avg_margin_percentage = np.mean(np.abs(margins) / actual.values) * 100
    return avg_margin_percentage

# Function to calculate directional accuracy
def directional_accuracy(actual, predicted):
    actual_diff = np.sign(np.diff(actual.values, prepend=actual.values[0]))
    predicted_diff = np.sign(np.diff(predicted, prepend=predicted[0]))
    accuracy = np.mean(actual_diff == predicted_diff) * 100
    return accuracy

# List of tickers
tickers = ["XOM", "CVX", "COP"]

# Loop through each ticker
for ticker in tickers:
    # Download historical data for each ticker
    historical_data = yf.download(ticker, start="2010-01-01", end="2024-01-01")
    data = yf.download(ticker, start="2010-01-01", end="2022-01-01")
    close_prices = data['Close'].values

    # Assuming yearly differencing might be needed
    days_in_year = 365
    differenced = difference(close_prices, days_in_year)

    # Fit ARIMA model on the differenced data
    model = ARIMA(differenced, order=(1,1,1))
    model_fit = model.fit()

    # Forecast for the next two years (2022 to 2024)
    forecast = model_fit.forecast(steps=2*365)  # daily data

    # Invert the differenced forecast to something usable
    history = list(close_prices)
    predictions = []
    day = 1
    for yhat in forecast:
        inverted = inverse_difference(history, yhat, days_in_year)
        predictions.append(inverted)
        history.append(inverted)
        day += 1

    # Plotting the results for historical closing prices and forecasts
    plt.figure(figsize=(12, 6))
    plt.plot(historical_data.index, historical_data['Close'], label='Historical Closing Prices')
    forecast_index = pd.date_range(start='2022-01-01', periods=730, freq='D')
    plt.plot(forecast_index, predictions, color='red', label='Forecasted Closing Prices')
    plt.title(f'{ticker} ARIMA Forecast of Future Stock Prices')
    plt.xlabel('Date')
    plt.ylabel('Stock Price')
    plt.legend()
    plt.show()

    # Plotting actual prices and predicted prices
    plt.figure(figsize=(12, 6))
    plt.plot(historical_data.loc['2022-01-01':].index, historical_data.loc['2022-01-01':]['Close'], label='Actual Prices', color='blue')
    plt.plot(forecast_index, predictions, label='Predicted Prices', color='orange')
    plt.legend()
    plt.title(f"{ticker} Stock Price Prediction with ARIMA")
    plt.xlabel("Date")
    plt.ylabel("Price")
    plt.show()

    # Calculate and print the average margin of difference
    actual_prices = historical_data.loc['2022-01-01':]['Close']
    predicted_prices = pd.Series(predictions, index=forecast_index)
    avg_margin = average_margin_of_difference(actual_prices, predicted_prices[:len(actual_prices)])
    avg_margin_percentage = average_margin_of_difference_percentage(actual_prices, predicted_prices[:len(actual_prices)])
    direction_accuracy = directional_accuracy(actual_prices, predicted_prices[:len(actual_prices)])

    print(f"\nAverage margin of difference for {ticker}: {avg_margin:.2f}")
    print(f"Average margin of difference for {ticker} (percentage): {avg_margin_percentage:.2f}%")
    print(f"Directional accuracy for {ticker}: {direction_accuracy:.2f}%")

import yfinance as yf
import pandas as pd
from statsmodels.tsa.arima.model import ARIMA
import matplotlib.pyplot as plt
import numpy as np
from sklearn.metrics import mean_absolute_error, mean_squared_error

# Function to create a differenced series to make the data stationary
def difference(dataset, interval=1):
    diff = list()
    for i in range(interval, len(dataset)):
        value = dataset[i] - dataset[i - interval]
        diff.append(value)
    return np.array(diff)

# Function to invert differenced value
def inverse_difference(history, yhat, interval=1):
    return yhat + history[-interval]

# Function to calculate the average margin of difference between actual and predicted prices
def average_margin_of_difference(actual, predicted):
    margins = actual - predicted
    avg_margin = np.mean(np.abs(margins))
    return avg_margin

# Function to assess the accuracy of predictions
def assess_accuracy(actual, predicted):
    mae = mean_absolute_error(actual, predicted)
    mse = mean_squared_error(actual, predicted)
    rmse = np.sqrt(mse)
    return mae, mse, rmse

# List of tickers
tickers = ["XOM", "CVX", "COP"]

# Loop through each ticker
for ticker in tickers:
    # Download historical data for each ticker
    historical_data = yf.download(ticker, start="2010-01-01", end="2024-01-01")
    data = yf.download(ticker, start="2010-01-01", end="2022-01-01")
    close_prices = data['Close'].values

    # Assuming yearly differencing might be needed
    days_in_year = 365
    differenced = difference(close_prices, days_in_year)

    # Fit ARIMA model on the differenced data
    model = ARIMA(differenced, order=(1,1,1))
    model_fit = model.fit()

    # Forecast for the next two years (2022 to 2024)
    forecast = model_fit.forecast(steps=2*365)  # daily data

    # Invert the differenced forecast to something usable
    history = list(close_prices)
    predictions = []
    day = 1
    for yhat in forecast:
        inverted = inverse_difference(history, yhat, days_in_year)
        predictions.append(inverted)
        history.append(inverted)
        day += 1

    # Plotting the results for historical closing prices and forecasts
    plt.figure(figsize=(12, 6))
    plt.plot(historical_data.index, historical_data['Close'], label='Historical Closing Prices')
    forecast_index = pd.date_range(start='2022-01-01', periods=730, freq='D')
    plt.plot(forecast_index, predictions, color='red', label='Forecasted Closing Prices')
    plt.title(f'{ticker} ARIMA Forecast of Future Stock Prices')
    plt.xlabel('Date')
    plt.ylabel('Stock Price')
    plt.legend()
    plt.show()

    # Plotting actual prices and predicted prices
    plt.figure(figsize=(12, 6))
    plt.plot(historical_data.loc['2022-01-01':].index, historical_data.loc['2022-01-01':]['Close'], label='Actual Prices', color='blue')
    plt.plot(forecast_index, predictions, label='Predicted Prices', color='orange')
    plt.legend()
    plt.title(f"{ticker} Stock Price Prediction with ARIMA")
    plt.xlabel("Date")
    plt.ylabel("Price")
    plt.show()

    # Calculate and print the average margin of difference
    actual_prices = historical_data.loc['2022-01-01':]['Close']
    predicted_prices = pd.Series(predictions, index=forecast_index)
    avg_margin = average_margin_of_difference(actual_prices, predicted_prices[:len(actual_prices)])
    print(f"Average margin of difference for {ticker}: {avg_margin:.2f}")

    # Assess and print the accuracy of the predictions
    mae, mse, rmse = assess_accuracy(actual_prices, predicted_prices[:len(actual_prices)])
    print(f"Accuracy of predictions for {ticker}:")
    print(f"Mean Absolute Error (MAE): {mae:.2f}")
    print(f"Mean Squared Error (MSE): {mse:.2f}")
    print(f"Root Mean Squared Error (RMSE): {rmse:.2f}")

"""#### LSTM"""

# Commented out IPython magic to ensure Python compatibility.
# %%time
#  # Import Libraries
# import yfinance as yf
# import pandas as pd
# import numpy as np
# from sklearn.preprocessing import MinMaxScaler
# from tensorflow.keras.models import Sequential
# from tensorflow.keras.layers import LSTM, Dense, Dropout
# from sklearn.metrics import mean_absolute_error, mean_squared_error
# import matplotlib.pyplot as plt
# import math
# 
# # Function to create LSTM model and evaluate it
# def evaluate_lstm(stock_ticker):
#     print(f"Evaluating {stock_ticker}")
# 
#     # Fetch Data
#     historical_data = yf.download(stock_ticker, start="2010-01-01", end="2024-01-01")
#     data = yf.download(stock_ticker, start="2010-01-01", end="2022-01-01")
#     closing_prices = data['Close']
#     scaler = MinMaxScaler()
#     scaled_data = scaler.fit_transform(closing_prices.values.reshape(-1, 1))
# 
#     # Prepare Data
#     SEQ_LENGTH = 60
#     x, y = create_sequences(scaled_data, SEQ_LENGTH)
#     split = int(0.8 * len(x))
#     x_train, x_val = x[:split], x[split:]
#     y_train, y_val = y[:split], y[split:]
# 
#     # Build Model
#     model = Sequential()
#     model.add(LSTM(50, return_sequences=True, input_shape=(SEQ_LENGTH, 1)))
#     model.add(Dropout(0.2))
#     model.add(LSTM(50, return_sequences=False))
#     model.add(Dense(25))
#     model.add(Dense(1))
#     model.compile(optimizer='adam', loss='mean_squared_error')
# 
#     # Train Model
#     history = model.fit(x_train, y_train, validation_data=(x_val, y_val), batch_size=32, epochs=50)
# 
#     # Evaluate Model
#     test_data = yf.download(stock_ticker, start="2022-01-01", end="2024-01-01")
#     scaled_test_data = scaler.transform(test_data['Close'].values.reshape(-1, 1))
#     x_test, y_test = create_sequences(scaled_test_data, SEQ_LENGTH)
# 
#     predictions = model.predict(x_test)
#     predictions = scaler.inverse_transform(predictions)
# 
#     # Calculate error metrics
#     mae = mean_absolute_error(y_test, predictions)
#     mse = mean_squared_error(y_test, predictions)
#     rmse = math.sqrt(mse)
# 
#     print(f"{stock_ticker} - Mean Absolute Error (MAE): {mae}")
#     print(f"{stock_ticker} - Mean Squared Error (MSE): {mse}")
#     print(f"{stock_ticker} - Root Mean Squared Error (RMSE): {rmse}")
# 
#     # Plot training and validation loss
#     plt.figure(figsize=(12, 6))
#     plt.plot(history.history['loss'], label='Training Loss')
#     plt.plot(history.history['val_loss'], label='Validation Loss')
#     plt.legend()
#     plt.title(f"Training and Validation Loss for {stock_ticker}")
#     plt.xlabel("Epochs")
#     plt.ylabel("Loss")
#     plt.show()
# 
#     plt.figure(figsize=(12, 6))
#     plt.plot(historical_data['Close'], label='Historical Prices', color='blue')
#     forecast_dates = pd.date_range(start=test_data.index[SEQ_LENGTH], periods=len(predictions), freq='B')
#     plt.plot(forecast_dates, predictions.flatten(), label='Predicted Prices', color='red')
#     plt.legend()
#     plt.title(f"{stock_ticker} Full Stock Price Prediction with LSTM")
#     plt.xlabel("Date")
#     plt.ylabel("Price")
#     plt.show()
# 
#     # Plot actual vs predicted prices
#     plt.figure(figsize=(12, 6))
#     plt.plot(test_data.index[SEQ_LENGTH:], test_data['Close'][SEQ_LENGTH:], label='Actual Prices')
#     plt.plot(test_data.index[SEQ_LENGTH:], predictions, label='Predicted Prices')
#     plt.legend()
#     plt.title(f"{stock_ticker} Stock Price Prediction with LSTM")
#     plt.xlabel("Date")
#     plt.ylabel("Price")
#     plt.show()
# 
# 
# # Helper function to create sequences
# def create_sequences(data, seq_length):
#     x = []
#     y = []
#     for i in range(seq_length, len(data)):
#         x.append(data[i - seq_length:i])
#         y.append(data[i])
#     return np.array(x), np.array(y)
# 
# 
# # Evaluate for multiple stocks
# for sector in [""]
#   for ticker in ["XOM", "CVX", "COP"]:
#       evaluate_lstm(ticker)
#

# Import Libraries
import yfinance as yf
import pandas as pd
import numpy as np
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
from sklearn.metrics import mean_absolute_error, mean_squared_error
import matplotlib.pyplot as plt
import math

# Function to create LSTM model and evaluate it
def evaluate_lstm(stock_ticker):
    print(f"Evaluating {stock_ticker}")

    # Fetch Data
    historical_data = yf.download(stock_ticker, start="2010-01-01", end="2024-01-01")
    data = yf.download(stock_ticker, start="2010-01-01", end="2022-01-01")
    closing_prices = data['Close']
    scaler = MinMaxScaler()
    scaled_data = scaler.fit_transform(closing_prices.values.reshape(-1, 1))

    # Prepare Data
    SEQ_LENGTH = 60
    x, y = create_sequences(scaled_data, SEQ_LENGTH)
    split = int(0.8 * len(x))
    x_train, x_val = x[:split], x[split:]
    y_train, y_val = y[:split], y[split:]

    # Build Model
    model = Sequential()
    model.add(LSTM(50, return_sequences=True, input_shape=(SEQ_LENGTH, 1)))
    model.add(Dropout(0.2))
    model.add(LSTM(50, return_sequences=False))
    model.add(Dense(25))
    model.add(Dense(1))
    model.compile(optimizer='adam', loss='mean_squared_error')

    # Train Model
    history = model.fit(x_train, y_train, validation_data=(x_val, y_val), batch_size=32, epochs=50)

    # Evaluate Model
    test_data = yf.download(stock_ticker, start="2022-01-01", end="2024-01-01")
    scaled_test_data = scaler.transform(test_data['Close'].values.reshape(-1, 1))
    x_test, y_test = create_sequences(scaled_test_data, SEQ_LENGTH)

    predictions = model.predict(x_test)
    predictions = scaler.inverse_transform(predictions)

    # Calculate error metrics
    mae = mean_absolute_error(y_test, predictions)
    mse = mean_squared_error(y_test, predictions)
    rmse = math.sqrt(mse)

    print(f"{stock_ticker} - Mean Absolute Error (MAE): {mae}")
    print(f"{stock_ticker} - Mean Squared Error (MSE): {mse}")
    print(f"{stock_ticker} - Root Mean Squared Error (RMSE): {rmse}")

    # Plot training and validation loss
    plt.figure(figsize=(12, 6))
    plt.plot(history.history['loss'], label='Training Loss')
    plt.plot(history.history['val_loss'], label='Validation Loss')
    plt.legend()
    plt.title(f"Training and Validation Loss for {stock_ticker}")
    plt.xlabel("Epochs")
    plt.ylabel("Loss")
    plt.show()

    plt.figure(figsize=(12, 6))
    plt.plot(historical_data['Close'], label='Historical Prices', color='blue')
    forecast_dates = pd.date_range(start=test_data.index[SEQ_LENGTH], periods=len(predictions), freq='B')
    plt.plot(forecast_dates, predictions.flatten(), label='Predicted Prices', color='red')
    plt.legend()
    plt.title(f"{stock_ticker} Full Stock Price Prediction with LSTM")
    plt.xlabel("Date")
    plt.ylabel("Price")
    plt.show()

    # Plot actual vs predicted prices
    plt.figure(figsize=(12, 6))
    plt.plot(test_data.index[SEQ_LENGTH:], test_data['Close'][SEQ_LENGTH:], label='Actual Prices')
    plt.plot(test_data.index[SEQ_LENGTH:], predictions, label='Predicted Prices')
    plt.legend()
    plt.title(f"{stock_ticker} Stock Price Prediction with LSTM")
    plt.xlabel("Date")
    plt.ylabel("Price")
    plt.show()

    # Calculate and print the average margin of difference
    avg_margin = average_margin_of_difference(test_data['Close'][SEQ_LENGTH:], predictions.flatten())
    avg_margin_percentage = average_margin_of_difference_percentage(test_data['Close'][SEQ_LENGTH:], predictions.flatten())
    direction_accuracy = directional_accuracy(test_data['Close'][SEQ_LENGTH:], predictions.flatten())

    print(f"Average margin of difference for {stock_ticker}: {avg_margin:.2f}")
    print(f"Average margin of difference for {stock_ticker} (percentage): {avg_margin_percentage:.2f}%")
    print(f"Directional accuracy for {stock_ticker}: {direction_accuracy:.2f}%")

# Helper function to create sequences
def create_sequences(data, seq_length):
    x = []
    y = []
    for i in range(seq_length, len(data)):
        x.append(data[i - seq_length:i])
        y.append(data[i])
    return np.array(x), np.array(y)

# Function to calculate the average margin of difference between actual and predicted prices
def average_margin_of_difference(actual, predicted):
    margins = actual.values - predicted
    avg_margin = np.mean(np.abs(margins))
    return avg_margin

# Function to calculate the average margin of difference as a percentage
def average_margin_of_difference_percentage(actual, predicted):
    margins = actual.values - predicted
    avg_margin_percentage = np.mean(np.abs(margins) / actual.values) * 100
    return avg_margin_percentage

# Function to calculate directional accuracy
def directional_accuracy(actual, predicted):
    actual_diff = np.sign(np.diff(actual.values, prepend=actual.values[0]))
    predicted_diff = np.sign(np.diff(predicted, prepend=predicted[0]))
    accuracy = np.mean(actual_diff == predicted_diff) * 100
    return accuracy

# Evaluate for multiple stocks
for ticker in ["XOM", "CVX", "COP"]:
    evaluate_lstm(ticker)

"""#### FB Prophet

##### Forecast start - 2022
"""

# beginning of forecast is 2022
from prophet import Prophet
import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt

def run_prophet(ticker):
    # Download data
    data = yf.download(ticker, start="2010-01-01", end="2024-01-01")
    df = pd.DataFrame(data['Close'])
    df.reset_index(inplace=True)
    df.rename(columns={'Date': 'ds', 'Close': 'y'}, inplace=True)

    # Fit the Prophet model on data up to the beginning of 2023
    m = Prophet(daily_seasonality=False)
    m.fit(df[df['ds'] < '2022-01-01'])  # Train only on data before 2023

    # Create future dataframe for forecasting
    future = m.make_future_dataframe(periods=len(data['2022-01-01':]), freq='B')
    forecast = m.predict(future)

    plt.figure(figsize=(12, 6))
    plt.plot(df['ds'], df['y'], label='Historical Prices')
    plt.plot(forecast['ds'], forecast['yhat'], color='red', label='Predicted Prices')
    plt.title(f"{ticker} Stock Price Forecast with Prophet")
    plt.xlabel("Date")
    plt.ylabel("Price")
    plt.legend()
    plt.show()
    # Plot historical and predicted prices
    plt.figure(figsize=(12, 6))
    plt.plot(df['ds'], df['y'], label='Historical Prices', color='blue')  # Historical prices

    # Only plot predicted prices starting from 2023
    forecasted_data = forecast[forecast['ds'] >= '2022-01-01']
    plt.plot(forecasted_data['ds'], forecasted_data['yhat'], color='red', label='Predicted Prices')  # Predicted prices

    plt.title(f"{ticker} Stock Price Forecast with Prophet")
    plt.xlabel("Date")
    plt.ylabel("Price")
    plt.legend()
    plt.show()

    plt.figure(figsize=(12, 6))
    # Filter actual data for plotting
    actual_data = df[df['ds'] >= '2022-01-01']
    plt.plot(actual_data['ds'], actual_data['y'], label='Actual Prices', color='blue')

    # Filter forecast data for plotting
    forecasted_data = forecast[forecast['ds'] >= '2022-01-01']
    plt.plot(forecasted_data['ds'], forecasted_data['yhat'], label='Predicted Prices', color='orange')

    plt.title(f"{ticker} Stock Price Prediction with Prophet")
    plt.xlabel("Date")
    plt.ylabel("Price")
    plt.legend()
    plt.show()

run_prophet("XOM")
run_prophet("CVX")
run_prophet("COP")

# beginning of forecast is 2022
from prophet import Prophet
import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

def run_prophet(ticker):
    # Download data
    data = yf.download(ticker, start="2010-01-01", end="2024-01-01")
    df = pd.DataFrame(data['Close'])
    df.reset_index(inplace=True)
    df.rename(columns={'Date': 'ds', 'Close': 'y'}, inplace=True)

    # Fit the Prophet model on data up to the beginning of 2022
    m = Prophet(daily_seasonality=False)
    m.fit(df[df['ds'] < '2022-01-01'])  # Train only on data before 2022

    # Create future dataframe for forecasting
    future = m.make_future_dataframe(periods=len(data['2022-01-01':]), freq='B')
    forecast = m.predict(future)

    plt.figure(figsize=(12, 6))
    plt.plot(df['ds'], df['y'], label='Historical Prices')
    plt.plot(forecast['ds'], forecast['yhat'], color='red', label='Predicted Prices')
    plt.title(f"{ticker} Stock Price Forecast with Prophet")
    plt.xlabel("Date")
    plt.ylabel("Price")
    plt.legend()
    plt.show()

    # Plot historical and predicted prices
    plt.figure(figsize=(12, 6))
    plt.plot(df['ds'], df['y'], label='Historical Prices', color='blue')  # Historical prices

    # Only plot predicted prices starting from 2022
    forecasted_data = forecast[forecast['ds'] >= '2022-01-01']
    plt.plot(forecasted_data['ds'], forecasted_data['yhat'], color='red', label='Predicted Prices')  # Predicted prices

    plt.title(f"{ticker} Stock Price Forecast with Prophet")
    plt.xlabel("Date")
    plt.ylabel("Price")
    plt.legend()
    plt.show()

    plt.figure(figsize=(12, 6))
    # Filter actual data for plotting
    actual_data = df[df['ds'] >= '2022-01-01']
    plt.plot(actual_data['ds'], actual_data['y'], label='Actual Prices', color='blue')

    # Filter forecast data for plotting
    forecasted_data = forecast[forecast['ds'] >= '2022-01-01']
    plt.plot(forecasted_data['ds'], forecasted_data['yhat'], label='Predicted Prices', color='orange')

    plt.title(f"{ticker} Stock Price Prediction with Prophet")
    plt.xlabel("Date")
    plt.ylabel("Price")
    plt.legend()
    plt.show()

    # Calculate and print the average margin of difference
    avg_margin = average_margin_of_difference(actual_data['y'], forecasted_data['yhat'])
    avg_margin_percentage = average_margin_of_difference_percentage(actual_data['y'], forecasted_data['yhat'])
    direction_accuracy = directional_accuracy(actual_data['y'], forecasted_data['yhat'])

    print(f"Average margin of difference for {ticker}: {avg_margin:.2f}")
    print(f"Average margin of difference for {ticker} (percentage): {avg_margin_percentage:.2f}%")
    print(f"Directional accuracy for {ticker}: {direction_accuracy:.2f}%")

# Function to calculate the average margin of difference between actual and predicted prices
def average_margin_of_difference(actual, predicted):
    margins = actual.values - predicted.values
    avg_margin = np.mean(np.abs(margins))
    return avg_margin

# Function to calculate the average margin of difference as a percentage
def average_margin_of_difference_percentage(actual, predicted):
    margins = actual.values - predicted.values
    avg_margin_percentage = np.mean(np.abs(margins) / actual.values) * 100
    return avg_margin_percentage

# Function to calculate directional accuracy
def directional_accuracy(actual, predicted):
    actual_diff = np.sign(np.diff(actual.values, prepend=actual.values[0]))
    predicted_diff = np.sign(np.diff(predicted.values, prepend=predicted.values[0]))
    accuracy = np.mean(actual_diff == predicted_diff) * 100
    return accuracy

# Run the Prophet model for multiple stocks
run_prophet("XOM")
run_prophet("CVX")
run_prophet("COP")

"""##### Forecast start - 2023"""

# beginning of forecast is 2023
from prophet import Prophet
import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt

def run_prophet(ticker):
    # Download data
    data = yf.download(ticker, start="2010-01-01", end="2024-01-01")
    df = pd.DataFrame(data['Close'])
    df.reset_index(inplace=True)
    df.rename(columns={'Date': 'ds', 'Close': 'y'}, inplace=True)

    # Fit the Prophet model on data up to the beginning of 2023
    m = Prophet(daily_seasonality=False)
    m.fit(df[df['ds'] < '2023-01-01'])  # Train only on data before 2023

    # Create future dataframe for forecasting
    future = m.make_future_dataframe(periods=len(data['2023-01-01':]), freq='B')
    forecast = m.predict(future)

    plt.figure(figsize=(12, 6))
    plt.plot(df['ds'], df['y'], label='Historical Prices')
    plt.plot(forecast['ds'], forecast['yhat'], color='red', label='Predicted Prices')
    plt.title(f"{ticker} Stock Price Forecast with Prophet")
    plt.xlabel("Date")
    plt.ylabel("Price")
    plt.legend()
    plt.show()
    # Plot historical and predicted prices
    plt.figure(figsize=(12, 6))
    plt.plot(df['ds'], df['y'], label='Historical Prices', color='blue')  # Historical prices

    # Only plot predicted prices starting from 2023
    forecasted_data = forecast[forecast['ds'] >= '2023-01-01']
    plt.plot(forecasted_data['ds'], forecasted_data['yhat'], color='red', label='Predicted Prices')  # Predicted prices

    plt.title(f"{ticker} Stock Price Forecast with Prophet")
    plt.xlabel("Date")
    plt.ylabel("Price")
    plt.legend()
    plt.show()

    plt.figure(figsize=(12, 6))
    # Filter actual data for plotting
    actual_data = df[df['ds'] >= '2022-01-01']
    plt.plot(actual_data['ds'], actual_data['y'], label='Actual Prices', color='blue')

    # Filter forecast data for plotting
    forecasted_data = forecast[forecast['ds'] >= '2022-01-01']
    plt.plot(forecasted_data['ds'], forecasted_data['yhat'], label='Predicted Prices', color='orange')

    plt.title(f"{ticker} Stock Price Prediction with Prophet")
    plt.xlabel("Date")
    plt.ylabel("Price")
    plt.legend()
    plt.show()

run_prophet("XOM")
run_prophet("CVX")
run_prophet("COP")

# beginning of forecast is 2022
from prophet import Prophet
import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

def run_prophet(ticker):
    # Download data
    data = yf.download(ticker, start="2010-01-01", end="2024-01-01")
    df = pd.DataFrame(data['Close'])
    df.reset_index(inplace=True)
    df.rename(columns={'Date': 'ds', 'Close': 'y'}, inplace=True)

    # Fit the Prophet model on data up to the beginning of 2022
    m = Prophet(daily_seasonality=False)
    m.fit(df[df['ds'] < '2023-01-01'])  # Train only on data before 2022

    # Create future dataframe for forecasting
    future = m.make_future_dataframe(periods=len(data['2023-01-01':]), freq='B')
    forecast = m.predict(future)

    plt.figure(figsize=(12, 6))
    plt.plot(df['ds'], df['y'], label='Historical Prices')
    plt.plot(forecast['ds'], forecast['yhat'], color='red', label='Predicted Prices')
    plt.title(f"{ticker} Stock Price Forecast with Prophet")
    plt.xlabel("Date")
    plt.ylabel("Price")
    plt.legend()
    plt.show()

    # Plot historical and predicted prices
    plt.figure(figsize=(12, 6))
    plt.plot(df['ds'], df['y'], label='Historical Prices', color='blue')  # Historical prices

    # Only plot predicted prices starting from 2022
    forecasted_data = forecast[forecast['ds'] >= '2023-01-01']
    plt.plot(forecasted_data['ds'], forecasted_data['yhat'], color='red', label='Predicted Prices')  # Predicted prices

    plt.title(f"{ticker} Stock Price Forecast with Prophet")
    plt.xlabel("Date")
    plt.ylabel("Price")
    plt.legend()
    plt.show()

    plt.figure(figsize=(12, 6))
    # Filter actual data for plotting
    actual_data = df[df['ds'] >= '2022-01-01']
    plt.plot(actual_data['ds'], actual_data['y'], label='Actual Prices', color='blue')

    # Filter forecast data for plotting
    forecasted_data = forecast[forecast['ds'] >= '2022-01-01']
    plt.plot(forecasted_data['ds'], forecasted_data['yhat'], label='Predicted Prices', color='orange')

    plt.title(f"{ticker} Stock Price Prediction with Prophet")
    plt.xlabel("Date")
    plt.ylabel("Price")
    plt.legend()
    plt.show()

    # Calculate and print the average margin of difference
    avg_margin = average_margin_of_difference(actual_data['y'], forecasted_data['yhat'])
    avg_margin_percentage = average_margin_of_difference_percentage(actual_data['y'], forecasted_data['yhat'])
    direction_accuracy = directional_accuracy(actual_data['y'], forecasted_data['yhat'])

    print(f"Average margin of difference for {ticker}: {avg_margin:.2f}")
    print(f"Average margin of difference for {ticker} (percentage): {avg_margin_percentage:.2f}%")
    print(f"Directional accuracy for {ticker}: {direction_accuracy:.2f}%")

# Function to calculate the average margin of difference between actual and predicted prices
def average_margin_of_difference(actual, predicted):
    margins = actual.values - predicted.values
    avg_margin = np.mean(np.abs(margins))
    return avg_margin

# Function to calculate the average margin of difference as a percentage
def average_margin_of_difference_percentage(actual, predicted):
    margins = actual.values - predicted.values
    avg_margin_percentage = np.mean(np.abs(margins) / actual.values) * 100
    return avg_margin_percentage

# Function to calculate directional accuracy
def directional_accuracy(actual, predicted):
    actual_diff = np.sign(np.diff(actual.values, prepend=actual.values[0]))
    predicted_diff = np.sign(np.diff(predicted.values, prepend=predicted.values[0]))
    accuracy = np.mean(actual_diff == predicted_diff) * 100
    return accuracy

# Run the Prophet model for multiple stocks
run_prophet("XOM")
run_prophet("CVX")
run_prophet("COP")

"""### Materials Sector Models

#### ARIMA
"""

import yfinance as yf
import pandas as pd
from statsmodels.tsa.arima.model import ARIMA
import matplotlib.pyplot as plt
import numpy as np

# Function to create a differenced series to make the data stationary
def difference(dataset, interval=1):
    diff = list()
    for i in range(interval, len(dataset)):
        value = dataset[i] - dataset[i - interval]
        diff.append(value)
    return np.array(diff)

# Function to invert differenced value
def inverse_difference(history, yhat, interval=1):
    return yhat + history[-interval]

# List of tickers
tickers = ["LIN", "SCCO", "SHW"]

# Loop through each ticker
for ticker in tickers:
    # Download historical data for each ticker
    historical_data = yf.download(ticker, start="2010-01-01", end="2024-01-01")
    data = yf.download(ticker, start="2010-01-01", end="2022-01-01")
    close_prices = data['Close'].values

    # Assuming yearly differencing might be needed
    days_in_year = 365
    differenced = difference(close_prices, days_in_year)

    # Fit ARIMA model on the differenced data
    model = ARIMA(differenced, order=(1,1,1))
    model_fit = model.fit()

    # Forecast for the next two years (2022 to 2024)
    forecast = model_fit.forecast(steps=2*365)  # daily data

    # Invert the differenced forecast to something usable
    history = list(close_prices)
    predictions = []
    day = 1
    for yhat in forecast:
        inverted = inverse_difference(history, yhat, days_in_year)
        predictions.append(inverted)
        history.append(inverted)
        day += 1

    # Plotting the results for historical closing prices and forecasts
    plt.figure(figsize=(12, 6))
    plt.plot(historical_data.index, historical_data['Close'], label='Historical Closing Prices')
    forecast_index = pd.date_range(start='2022-01-01', periods=730, freq='D')
    plt.plot(forecast_index, predictions, color='red', label='Forecasted Closing Prices')
    plt.title(f'{ticker} ARIMA Forecast of Future Stock Prices')
    plt.xlabel('Date')
    plt.ylabel('Stock Price')
    plt.legend()
    plt.show()

    # Plotting actual prices and predicted prices
    plt.figure(figsize=(12, 6))
    plt.plot(historical_data.loc['2022-01-01':].index, historical_data.loc['2022-01-01':]['Close'], label='Actual Prices', color='blue')
    plt.plot(forecast_index, predictions, label='Predicted Prices', color='orange')
    plt.legend()
    plt.title(f"{ticker} Stock Price Prediction with ARIMA")
    plt.xlabel("Date")
    plt.ylabel("Price")
    plt.show()

import yfinance as yf
import pandas as pd
from statsmodels.tsa.arima.model import ARIMA
import matplotlib.pyplot as plt
import numpy as np

# Function to create a differenced series to make the data stationary
def difference(dataset, interval=1):
    diff = list()
    for i in range(interval, len(dataset)):
        value = dataset[i] - dataset[i - interval]
        diff.append(value)
    return np.array(diff)

# Function to invert differenced value
def inverse_difference(history, yhat, interval=1):
    return yhat + history[-interval]

# Function to calculate the average margin of difference between actual and predicted prices
def average_margin_of_difference(actual, predicted):
    margins = actual.values - predicted
    avg_margin = np.mean(np.abs(margins))
    return avg_margin

# Function to calculate the average margin of difference as a percentage
def average_margin_of_difference_percentage(actual, predicted):
    margins = actual.values - predicted
    avg_margin_percentage = np.mean(np.abs(margins) / actual.values) * 100
    return avg_margin_percentage

# Function to calculate directional accuracy
def directional_accuracy(actual, predicted):
    actual_diff = np.sign(np.diff(actual.values, prepend=actual.values[0]))
    predicted_diff = np.sign(np.diff(predicted, prepend=predicted[0]))
    accuracy = np.mean(actual_diff == predicted_diff) * 100
    return accuracy

# List of tickers
tickers = ["LIN", "SCCO", "SHW"]

# Loop through each ticker
for ticker in tickers:
    # Download historical data for each ticker
    historical_data = yf.download(ticker, start="2010-01-01", end="2024-01-01")
    data = yf.download(ticker, start="2010-01-01", end="2022-01-01")
    close_prices = data['Close'].values

    # Assuming yearly differencing might be needed
    days_in_year = 365
    differenced = difference(close_prices, days_in_year)

    # Fit ARIMA model on the differenced data
    model = ARIMA(differenced, order=(1,1,1))
    model_fit = model.fit()

    # Forecast for the next two years (2022 to 2024)
    forecast = model_fit.forecast(steps=2*365)  # daily data

    # Invert the differenced forecast to something usable
    history = list(close_prices)
    predictions = []
    day = 1
    for yhat in forecast:
        inverted = inverse_difference(history, yhat, days_in_year)
        predictions.append(inverted)
        history.append(inverted)
        day += 1

    # Plotting the results for historical closing prices and forecasts
    plt.figure(figsize=(12, 6))
    plt.plot(historical_data.index, historical_data['Close'], label='Historical Closing Prices')
    forecast_index = pd.date_range(start='2022-01-01', periods=730, freq='D')
    plt.plot(forecast_index, predictions, color='red', label='Forecasted Closing Prices')
    plt.title(f'{ticker} ARIMA Forecast of Future Stock Prices')
    plt.xlabel('Date')
    plt.ylabel('Stock Price')
    plt.legend()
    plt.show()

    # Plotting actual prices and predicted prices
    plt.figure(figsize=(12, 6))
    plt.plot(historical_data.loc['2022-01-01':].index, historical_data.loc['2022-01-01':]['Close'], label='Actual Prices', color='blue')
    plt.plot(forecast_index, predictions, label='Predicted Prices', color='orange')
    plt.legend()
    plt.title(f"{ticker} Stock Price Prediction with ARIMA")
    plt.xlabel("Date")
    plt.ylabel("Price")
    plt.show()

    # Calculate and print the average margin of difference
    actual_prices = historical_data.loc['2022-01-01':]['Close']
    predicted_prices = pd.Series(predictions, index=forecast_index)
    avg_margin = average_margin_of_difference(actual_prices, predicted_prices[:len(actual_prices)])
    avg_margin_percentage = average_margin_of_difference_percentage(actual_prices, predicted_prices[:len(actual_prices)])
    direction_accuracy = directional_accuracy(actual_prices, predicted_prices[:len(actual_prices)])

    print(f"\nAverage margin of difference for {ticker}: {avg_margin:.2f}")
    print(f"Average margin of difference for {ticker} (percentage): {avg_margin_percentage:.2f}%")
    print(f"Directional accuracy for {ticker}: {direction_accuracy:.2f}%")

"""#### LSTM"""

# Commented out IPython magic to ensure Python compatibility.
# %%time
# def evaluate_lstm(stock_ticker):
#     print(f"Evaluating {stock_ticker}")
# 
#     # Fetch Data
#     historical_data = yf.download(stock_ticker, start="2010-01-01", end="2024-01-01")
#     data = yf.download(stock_ticker, start="2010-01-01", end="2022-01-01")
#     closing_prices = data['Close']
#     scaler = MinMaxScaler()
#     scaled_data = scaler.fit_transform(closing_prices.values.reshape(-1, 1))
# 
#     # Prepare Data
#     SEQ_LENGTH = 60
#     x, y = create_sequences(scaled_data, SEQ_LENGTH)
#     split = int(0.8 * len(x))
#     x_train, x_val = x[:split], x[split:]
#     y_train, y_val = y[:split], y[split:]
# 
#     # Build Model
#     model = Sequential()
#     model.add(LSTM(50, return_sequences=True, input_shape=(SEQ_LENGTH, 1)))
#     model.add(Dropout(0.2))
#     model.add(LSTM(50, return_sequences=False))
#     model.add(Dense(25))
#     model.add(Dense(1))
#     model.compile(optimizer='adam', loss='mean_squared_error')
# 
#     # Train Model
#     history = model.fit(x_train, y_train, validation_data=(x_val, y_val), batch_size=32, epochs=50)
# 
#     # Evaluate Model
#     test_data = yf.download(stock_ticker, start="2022-01-01", end="2024-01-01")
#     scaled_test_data = scaler.transform(test_data['Close'].values.reshape(-1, 1))
#     x_test, y_test = create_sequences(scaled_test_data, SEQ_LENGTH)
# 
#     predictions = model.predict(x_test)
#     predictions = scaler.inverse_transform(predictions)
# 
#     # Calculate error metrics
#     mae = mean_absolute_error(y_test, predictions)
#     mse = mean_squared_error(y_test, predictions)
#     rmse = math.sqrt(mse)
# 
#     print(f"{stock_ticker} - Mean Absolute Error (MAE): {mae}")
#     print(f"{stock_ticker} - Mean Squared Error (MSE): {mse}")
#     print(f"{stock_ticker} - Root Mean Squared Error (RMSE): {rmse}")
# 
#     # Plot training and validation loss
#     plt.figure(figsize=(12, 6))
#     plt.plot(history.history['loss'], label='Training Loss')
#     plt.plot(history.history['val_loss'], label='Validation Loss')
#     plt.legend()
#     plt.title(f"Training and Validation Loss for {stock_ticker}")
#     plt.xlabel("Epochs")
#     plt.ylabel("Loss")
#     plt.show()
# 
#     plt.figure(figsize=(12, 6))
#     plt.plot(historical_data['Close'], label='Historical Prices', color='blue')
#     forecast_dates = pd.date_range(start=test_data.index[SEQ_LENGTH], periods=len(predictions), freq='B')
#     plt.plot(forecast_dates, predictions.flatten(), label='Predicted Prices', color='red')
#     plt.legend()
#     plt.title(f"{stock_ticker} Full Stock Price Prediction with LSTM")
#     plt.xlabel("Date")
#     plt.ylabel("Price")
#     plt.show()
# 
#     # Plot actual vs predicted prices
#     plt.figure(figsize=(12, 6))
#     plt.plot(test_data.index[SEQ_LENGTH:], test_data['Close'][SEQ_LENGTH:], label='Actual Prices')
#     plt.plot(test_data.index[SEQ_LENGTH:], predictions, label='Predicted Prices')
#     plt.legend()
#     plt.title(f"{stock_ticker} Stock Price Prediction with LSTM")
#     plt.xlabel("Date")
#     plt.ylabel("Price")
#     plt.show()
# 
# 
# # Helper function to create sequences
# def create_sequences(data, seq_length):
#     x = []
#     y = []
#     for i in range(seq_length, len(data)):
#         x.append(data[i - seq_length:i])
#         y.append(data[i])
#     return np.array(x), np.array(y)
# 
# 
# # Evaluate for multiple stocks
# for ticker in ["LIN", "SCCO", "SHW"]:
#     evaluate_lstm(ticker)

# Import Libraries
import yfinance as yf
import pandas as pd
import numpy as np
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
from sklearn.metrics import mean_absolute_error, mean_squared_error
import matplotlib.pyplot as plt
import math

# Function to create LSTM model and evaluate it
def evaluate_lstm(stock_ticker):
    print(f"Evaluating {stock_ticker}")

    # Fetch Data
    historical_data = yf.download(stock_ticker, start="2010-01-01", end="2024-01-01")
    data = yf.download(stock_ticker, start="2010-01-01", end="2022-01-01")
    closing_prices = data['Close']
    scaler = MinMaxScaler()
    scaled_data = scaler.fit_transform(closing_prices.values.reshape(-1, 1))

    # Prepare Data
    SEQ_LENGTH = 60
    x, y = create_sequences(scaled_data, SEQ_LENGTH)
    split = int(0.8 * len(x))
    x_train, x_val = x[:split], x[split:]
    y_train, y_val = y[:split], y[split:]

    # Build Model
    model = Sequential()
    model.add(LSTM(50, return_sequences=True, input_shape=(SEQ_LENGTH, 1)))
    model.add(Dropout(0.2))
    model.add(LSTM(50, return_sequences=False))
    model.add(Dense(25))
    model.add(Dense(1))
    model.compile(optimizer='adam', loss='mean_squared_error')

    # Train Model
    history = model.fit(x_train, y_train, validation_data=(x_val, y_val), batch_size=32, epochs=50)

    # Evaluate Model
    test_data = yf.download(stock_ticker, start="2022-01-01", end="2024-01-01")
    scaled_test_data = scaler.transform(test_data['Close'].values.reshape(-1, 1))
    x_test, y_test = create_sequences(scaled_test_data, SEQ_LENGTH)

    predictions = model.predict(x_test)
    predictions = scaler.inverse_transform(predictions)

    # Calculate error metrics
    mae = mean_absolute_error(y_test, predictions)
    mse = mean_squared_error(y_test, predictions)
    rmse = math.sqrt(mse)

    print(f"{stock_ticker} - Mean Absolute Error (MAE): {mae}")
    print(f"{stock_ticker} - Mean Squared Error (MSE): {mse}")
    print(f"{stock_ticker} - Root Mean Squared Error (RMSE): {rmse}")

    # Plot training and validation loss
    plt.figure(figsize=(12, 6))
    plt.plot(history.history['loss'], label='Training Loss')
    plt.plot(history.history['val_loss'], label='Validation Loss')
    plt.legend()
    plt.title(f"Training and Validation Loss for {stock_ticker}")
    plt.xlabel("Epochs")
    plt.ylabel("Loss")
    plt.show()

    plt.figure(figsize=(12, 6))
    plt.plot(historical_data['Close'], label='Historical Prices', color='blue')
    forecast_dates = pd.date_range(start=test_data.index[SEQ_LENGTH], periods=len(predictions), freq='B')
    plt.plot(forecast_dates, predictions.flatten(), label='Predicted Prices', color='red')
    plt.legend()
    plt.title(f"{stock_ticker} Full Stock Price Prediction with LSTM")
    plt.xlabel("Date")
    plt.ylabel("Price")
    plt.show()

    # Plot actual vs predicted prices
    plt.figure(figsize=(12, 6))
    plt.plot(test_data.index[SEQ_LENGTH:], test_data['Close'][SEQ_LENGTH:], label='Actual Prices')
    plt.plot(test_data.index[SEQ_LENGTH:], predictions, label='Predicted Prices')
    plt.legend()
    plt.title(f"{stock_ticker} Stock Price Prediction with LSTM")
    plt.xlabel("Date")
    plt.ylabel("Price")
    plt.show()

    # Calculate and print the average margin of difference
    avg_margin = average_margin_of_difference(test_data['Close'][SEQ_LENGTH:], predictions.flatten())
    avg_margin_percentage = average_margin_of_difference_percentage(test_data['Close'][SEQ_LENGTH:], predictions.flatten())
    direction_accuracy = directional_accuracy(test_data['Close'][SEQ_LENGTH:], predictions.flatten())

    print(f"Average margin of difference for {stock_ticker}: {avg_margin:.2f}")
    print(f"Average margin of difference for {stock_ticker} (percentage): {avg_margin_percentage:.2f}%")
    print(f"Directional accuracy for {stock_ticker}: {direction_accuracy:.2f}%")

# Helper function to create sequences
def create_sequences(data, seq_length):
    x = []
    y = []
    for i in range(seq_length, len(data)):
        x.append(data[i - seq_length:i])
        y.append(data[i])
    return np.array(x), np.array(y)

# Function to calculate the average margin of difference between actual and predicted prices
def average_margin_of_difference(actual, predicted):
    margins = actual.values - predicted
    avg_margin = np.mean(np.abs(margins))
    return avg_margin

# Function to calculate the average margin of difference as a percentage
def average_margin_of_difference_percentage(actual, predicted):
    margins = actual.values - predicted
    avg_margin_percentage = np.mean(np.abs(margins) / actual.values) * 100
    return avg_margin_percentage

# Function to calculate directional accuracy
def directional_accuracy(actual, predicted):
    actual_diff = np.sign(np.diff(actual.values, prepend=actual.values[0]))
    predicted_diff = np.sign(np.diff(predicted, prepend=predicted[0]))
    accuracy = np.mean(actual_diff == predicted_diff) * 100
    return accuracy

# Evaluate for multiple stocks
for ticker in ["LIN", "SCCO", "SHW"]:
    evaluate_lstm(ticker)

"""#### FB Prophet"""

# Commented out IPython magic to ensure Python compatibility.
# %%time
# # beginning of forecast is 2023
# from prophet import Prophet
# import yfinance as yf
# import pandas as pd
# import matplotlib.pyplot as plt
# 
# def run_prophet(ticker):
#     # Download data
#     data = yf.download(ticker, start="2010-01-01", end="2024-01-01")
#     df = pd.DataFrame(data['Close'])
#     df.reset_index(inplace=True)
#     df.rename(columns={'Date': 'ds', 'Close': 'y'}, inplace=True)
# 
#     # Fit the Prophet model on data up to the beginning of 2023
#     m = Prophet(daily_seasonality=False)
#     m.fit(df[df['ds'] < '2023-01-01'])  # Train only on data before 2023
# 
#     # Create future dataframe for forecasting
#     future = m.make_future_dataframe(periods=len(data['2023-01-01':]), freq='B')
#     forecast = m.predict(future)
# 
#     plt.figure(figsize=(12, 6))
#     plt.plot(df['ds'], df['y'], label='Historical Prices')
#     plt.plot(forecast['ds'], forecast['yhat'], color='red', label='Predicted Prices')
#     plt.title(f"{ticker} Stock Price Forecast with Prophet")
#     plt.xlabel("Date")
#     plt.ylabel("Price")
#     plt.legend()
#     plt.show()
#     # Plot historical and predicted prices
#     plt.figure(figsize=(12, 6))
#     plt.plot(df['ds'], df['y'], label='Historical Prices', color='blue')  # Historical prices
# 
#     # Only plot predicted prices starting from 2023
#     forecasted_data = forecast[forecast['ds'] >= '2022-01-01']
#     plt.plot(forecasted_data['ds'], forecasted_data['yhat'], color='red', label='Predicted Prices')  # Predicted prices
# 
#     plt.title(f"{ticker} Stock Price Forecast with Prophet")
#     plt.xlabel("Date")
#     plt.ylabel("Price")
#     plt.legend()
#     plt.show()
# 
#     plt.figure(figsize=(12, 6))
#     # Filter actual data for plotting
#     actual_data = df[df['ds'] >= '2022-01-01']
#     plt.plot(actual_data['ds'], actual_data['y'], label='Actual Prices', color='blue')
# 
#     # Filter forecast data for plotting
#     forecasted_data = forecast[forecast['ds'] >= '2022-01-01']
#     plt.plot(forecasted_data['ds'], forecasted_data['yhat'], label='Predicted Prices', color='orange')
# 
#     plt.title(f"{ticker} Stock Price Prediction with Prophet")
#     plt.xlabel("Date")
#     plt.ylabel("Price")
#     plt.legend()
#     plt.show()
# 
# run_prophet("LIN")
# run_prophet("SCCO")
# run_prophet("SHW")
#

# beginning of forecast is 2022
from prophet import Prophet
import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

def run_prophet(ticker):
    # Download data
    data = yf.download(ticker, start="2010-01-01", end="2024-01-01")
    df = pd.DataFrame(data['Close'])
    df.reset_index(inplace=True)
    df.rename(columns={'Date': 'ds', 'Close': 'y'}, inplace=True)

    # Fit the Prophet model on data up to the beginning of 2022
    m = Prophet(daily_seasonality=False)
    m.fit(df[df['ds'] < '2022-01-01'])  # Train only on data before 2022

    # Create future dataframe for forecasting
    future = m.make_future_dataframe(periods=len(data['2022-01-01':]), freq='B')
    forecast = m.predict(future)

    plt.figure(figsize=(12, 6))
    plt.plot(df['ds'], df['y'], label='Historical Prices')
    plt.plot(forecast['ds'], forecast['yhat'], color='red', label='Predicted Prices')
    plt.title(f"{ticker} Stock Price Forecast with Prophet")
    plt.xlabel("Date")
    plt.ylabel("Price")
    plt.legend()
    plt.show()

    # Plot historical and predicted prices
    plt.figure(figsize=(12, 6))
    plt.plot(df['ds'], df['y'], label='Historical Prices', color='blue')  # Historical prices

    # Only plot predicted prices starting from 2022
    forecasted_data = forecast[forecast['ds'] >= '2022-01-01']
    plt.plot(forecasted_data['ds'], forecasted_data['yhat'], color='red', label='Predicted Prices')  # Predicted prices

    plt.title(f"{ticker} Stock Price Forecast with Prophet")
    plt.xlabel("Date")
    plt.ylabel("Price")
    plt.legend()
    plt.show()

    plt.figure(figsize=(12, 6))
    # Filter actual data for plotting
    actual_data = df[df['ds'] >= '2022-01-01']
    plt.plot(actual_data['ds'], actual_data['y'], label='Actual Prices', color='blue')

    # Filter forecast data for plotting
    forecasted_data = forecast[forecast['ds'] >= '2022-01-01']
    plt.plot(forecasted_data['ds'], forecasted_data['yhat'], label='Predicted Prices', color='orange')

    plt.title(f"{ticker} Stock Price Prediction with Prophet")
    plt.xlabel("Date")
    plt.ylabel("Price")
    plt.legend()
    plt.show()

    # Calculate and print the average margin of difference
    avg_margin = average_margin_of_difference(actual_data['y'], forecasted_data['yhat'])
    avg_margin_percentage = average_margin_of_difference_percentage(actual_data['y'], forecasted_data['yhat'])
    direction_accuracy = directional_accuracy(actual_data['y'], forecasted_data['yhat'])

    print(f"Average margin of difference for {ticker}: {avg_margin:.2f}")
    print(f"Average margin of difference for {ticker} (percentage): {avg_margin_percentage:.2f}%")
    print(f"Directional accuracy for {ticker}: {direction_accuracy:.2f}%")

# Function to calculate the average margin of difference between actual and predicted prices
def average_margin_of_difference(actual, predicted):
    margins = actual.values - predicted.values
    avg_margin = np.mean(np.abs(margins))
    return avg_margin

# Function to calculate the average margin of difference as a percentage
def average_margin_of_difference_percentage(actual, predicted):
    margins = actual.values - predicted.values
    avg_margin_percentage = np.mean(np.abs(margins) / actual.values) * 100
    return avg_margin_percentage

# Function to calculate directional accuracy
def directional_accuracy(actual, predicted):
    actual_diff = np.sign(np.diff(actual.values, prepend=actual.values[0]))
    predicted_diff = np.sign(np.diff(predicted.values, prepend=predicted.values[0]))
    accuracy = np.mean(actual_diff == predicted_diff) * 100
    return accuracy

# Run the Prophet model for multiple stocks
run_prophet("LIN")
run_prophet("SCCO")
run_prophet("SHW")

"""### Industrial Sector Models

#### ARIMA
"""

import yfinance as yf
import pandas as pd
from statsmodels.tsa.arima.model import ARIMA
import matplotlib.pyplot as plt
import numpy as np

# Function to create a differenced series to make the data stationary
def difference(dataset, interval=1):
    diff = list()
    for i in range(interval, len(dataset)):
        value = dataset[i] - dataset[i - interval]
        diff.append(value)
    return np.array(diff)

# Function to invert differenced value
def inverse_difference(history, yhat, interval=1):
    return yhat + history[-interval]

# List of tickers
tickers = ["GE", "CAT", "UNP"]

# Loop through each ticker
for ticker in tickers:
    # Download historical data for each ticker
    historical_data = yf.download(ticker, start="2010-01-01", end="2024-01-01")
    data = yf.download(ticker, start="2010-01-01", end="2022-01-01")
    close_prices = data['Close'].values

    # Assuming yearly differencing might be needed
    days_in_year = 365
    differenced = difference(close_prices, days_in_year)

    # Fit ARIMA model on the differenced data
    model = ARIMA(differenced, order=(1,1,1))
    model_fit = model.fit()

    # Forecast for the next two years (2022 to 2024)
    forecast = model_fit.forecast(steps=2*365)  # daily data

    # Invert the differenced forecast to something usable
    history = list(close_prices)
    predictions = []
    day = 1
    for yhat in forecast:
        inverted = inverse_difference(history, yhat, days_in_year)
        predictions.append(inverted)
        # print(f'Day {day}: {inverted:.2f}')
        history.append(inverted)
        day += 1

    # Plotting the results for historical closing prices and forecasts
    plt.figure(figsize=(12, 6))
    plt.plot(historical_data.index, historical_data['Close'], label='Historical Closing Prices')
    forecast_index = pd.date_range(start='2022-01-01', periods=730, freq='D')
    plt.plot(forecast_index, predictions, color='red', label='Forecasted Closing Prices')
    plt.title(f'{ticker} ARIMA Forecast of Future Stock Prices')
    plt.xlabel('Date')
    plt.ylabel('Stock Price')
    plt.legend()
    plt.show()

    # Plotting actual prices and predicted prices
    plt.figure(figsize=(12, 6))
    plt.plot(historical_data.loc['2022-01-01':].index, historical_data.loc['2022-01-01':]['Close'], label='Actual Prices', color='blue')
    plt.plot(forecast_index, predictions, label='Predicted Prices', color='orange')
    plt.legend()
    plt.title(f"{ticker} Stock Price Prediction with ARIMA")
    plt.xlabel("Date")
    plt.ylabel("Price")
    plt.show()

import yfinance as yf
import pandas as pd
from statsmodels.tsa.arima.model import ARIMA
import matplotlib.pyplot as plt
import numpy as np

# Function to create a differenced series to make the data stationary
def difference(dataset, interval=1):
    diff = list()
    for i in range(interval, len(dataset)):
        value = dataset[i] - dataset[i - interval]
        diff.append(value)
    return np.array(diff)

# Function to invert differenced value
def inverse_difference(history, yhat, interval=1):
    return yhat + history[-interval]

# Function to calculate the average margin of difference between actual and predicted prices
def average_margin_of_difference(actual, predicted):
    margins = actual.values - predicted
    avg_margin = np.mean(np.abs(margins))
    return avg_margin

# Function to calculate the average margin of difference as a percentage
def average_margin_of_difference_percentage(actual, predicted):
    margins = actual.values - predicted
    avg_margin_percentage = np.mean(np.abs(margins) / actual.values) * 100
    return avg_margin_percentage

# Function to calculate directional accuracy
def directional_accuracy(actual, predicted):
    actual_diff = np.sign(np.diff(actual.values, prepend=actual.values[0]))
    predicted_diff = np.sign(np.diff(predicted, prepend=predicted[0]))
    accuracy = np.mean(actual_diff == predicted_diff) * 100
    return accuracy

# List of tickers
tickers = ["GE", "CAT", "UNP"]

# Loop through each ticker
for ticker in tickers:
    # Download historical data for each ticker
    historical_data = yf.download(ticker, start="2010-01-01", end="2024-01-01")
    data = yf.download(ticker, start="2010-01-01", end="2022-01-01")
    close_prices = data['Close'].values

    # Assuming yearly differencing might be needed
    days_in_year = 365
    differenced = difference(close_prices, days_in_year)

    # Fit ARIMA model on the differenced data
    model = ARIMA(differenced, order=(1,1,1))
    model_fit = model.fit()

    # Forecast for the next two years (2022 to 2024)
    forecast = model_fit.forecast(steps=2*365)  # daily data

    # Invert the differenced forecast to something usable
    history = list(close_prices)
    predictions = []
    day = 1
    for yhat in forecast:
        inverted = inverse_difference(history, yhat, days_in_year)
        predictions.append(inverted)
        history.append(inverted)
        day += 1

    # Plotting the results for historical closing prices and forecasts
    plt.figure(figsize=(12, 6))
    plt.plot(historical_data.index, historical_data['Close'], label='Historical Closing Prices')
    forecast_index = pd.date_range(start='2022-01-01', periods=730, freq='D')
    plt.plot(forecast_index, predictions, color='red', label='Forecasted Closing Prices')
    plt.title(f'{ticker} ARIMA Forecast of Future Stock Prices')
    plt.xlabel('Date')
    plt.ylabel('Stock Price')
    plt.legend()
    plt.show()

    # Plotting actual prices and predicted prices
    plt.figure(figsize=(12, 6))
    plt.plot(historical_data.loc['2022-01-01':].index, historical_data.loc['2022-01-01':]['Close'], label='Actual Prices', color='blue')
    plt.plot(forecast_index, predictions, label='Predicted Prices', color='orange')
    plt.legend()
    plt.title(f"{ticker} Stock Price Prediction with ARIMA")
    plt.xlabel("Date")
    plt.ylabel("Price")
    plt.show()

    # Calculate and print the average margin of difference
    actual_prices = historical_data.loc['2022-01-01':]['Close']
    predicted_prices = pd.Series(predictions, index=forecast_index)
    avg_margin = average_margin_of_difference(actual_prices, predicted_prices[:len(actual_prices)])
    avg_margin_percentage = average_margin_of_difference_percentage(actual_prices, predicted_prices[:len(actual_prices)])
    direction_accuracy = directional_accuracy(actual_prices, predicted_prices[:len(actual_prices)])

    print(f"\nAverage margin of difference for {ticker}: {avg_margin:.2f}")
    print(f"Average margin of difference for {ticker} (percentage): {avg_margin_percentage:.2f}%")
    print(f"Directional accuracy for {ticker}: {direction_accuracy:.2f}%")

"""#### LSTM"""

# Commented out IPython magic to ensure Python compatibility.
# %%time
# def evaluate_lstm(stock_ticker):
#     print(f"Evaluating {stock_ticker}")
# 
#     # Fetch Data
#     historical_data = yf.download(stock_ticker, start="2010-01-01", end="2024-01-01")
#     data = yf.download(stock_ticker, start="2010-01-01", end="2022-01-01")
#     closing_prices = data['Close']
#     scaler = MinMaxScaler()
#     scaled_data = scaler.fit_transform(closing_prices.values.reshape(-1, 1))
# 
#     # Prepare Data
#     SEQ_LENGTH = 60
#     x, y = create_sequences(scaled_data, SEQ_LENGTH)
#     split = int(0.8 * len(x))
#     x_train, x_val = x[:split], x[split:]
#     y_train, y_val = y[:split], y[split:]
# 
#     # Build Model
#     model = Sequential()
#     model.add(LSTM(50, return_sequences=True, input_shape=(SEQ_LENGTH, 1)))
#     model.add(Dropout(0.2))
#     model.add(LSTM(50, return_sequences=False))
#     model.add(Dense(25))
#     model.add(Dense(1))
#     model.compile(optimizer='adam', loss='mean_squared_error')
# 
#     # Train Model
#     history = model.fit(x_train, y_train, validation_data=(x_val, y_val), batch_size=32, epochs=50)
# 
#     # Evaluate Model
#     test_data = yf.download(stock_ticker, start="2022-01-01", end="2024-01-01")
#     scaled_test_data = scaler.transform(test_data['Close'].values.reshape(-1, 1))
#     x_test, y_test = create_sequences(scaled_test_data, SEQ_LENGTH)
# 
#     predictions = model.predict(x_test)
#     predictions = scaler.inverse_transform(predictions)
# 
#     # Calculate error metrics
#     mae = mean_absolute_error(y_test, predictions)
#     mse = mean_squared_error(y_test, predictions)
#     rmse = math.sqrt(mse)
# 
#     print(f"{stock_ticker} - Mean Absolute Error (MAE): {mae}")
#     print(f"{stock_ticker} - Mean Squared Error (MSE): {mse}")
#     print(f"{stock_ticker} - Root Mean Squared Error (RMSE): {rmse}")
# 
#     # Plot training and validation loss
#     plt.figure(figsize=(12, 6))
#     plt.plot(history.history['loss'], label='Training Loss')
#     plt.plot(history.history['val_loss'], label='Validation Loss')
#     plt.legend()
#     plt.title(f"Training and Validation Loss for {stock_ticker}")
#     plt.xlabel("Epochs")
#     plt.ylabel("Loss")
#     plt.show()
# 
#     plt.figure(figsize=(12, 6))
#     plt.plot(historical_data['Close'], label='Historical Prices', color='blue')
#     forecast_dates = pd.date_range(start=test_data.index[SEQ_LENGTH], periods=len(predictions), freq='B')
#     plt.plot(forecast_dates, predictions.flatten(), label='Predicted Prices', color='red')
#     plt.legend()
#     plt.title(f"{stock_ticker} Full Stock Price Prediction with LSTM")
#     plt.xlabel("Date")
#     plt.ylabel("Price")
#     plt.show()
# 
#     # Plot actual vs predicted prices
#     plt.figure(figsize=(12, 6))
#     plt.plot(test_data.index[SEQ_LENGTH:], test_data['Close'][SEQ_LENGTH:], label='Actual Prices')
#     plt.plot(test_data.index[SEQ_LENGTH:], predictions, label='Predicted Prices')
#     plt.legend()
#     plt.title(f"{stock_ticker} Stock Price Prediction with LSTM")
#     plt.xlabel("Date")
#     plt.ylabel("Price")
#     plt.show()
# 
# # Helper function to create sequences
# def create_sequences(data, seq_length):
#     x = []
#     y = []
#     for i in range(seq_length, len(data)):
#         x.append(data[i - seq_length:i])
#         y.append(data[i])
#     return np.array(x), np.array(y)
# 
# 
# # Evaluate for multiple stocks
# for ticker in ["GE", "CAT", "UNP"]:
#     evaluate_lstm(ticker)

# Import Libraries
import yfinance as yf
import pandas as pd
import numpy as np
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
from sklearn.metrics import mean_absolute_error, mean_squared_error
import matplotlib.pyplot as plt
import math

# Function to create LSTM model and evaluate it
def evaluate_lstm(stock_ticker):
    print(f"Evaluating {stock_ticker}")

    # Fetch Data
    historical_data = yf.download(stock_ticker, start="2010-01-01", end="2024-01-01")
    data = yf.download(stock_ticker, start="2010-01-01", end="2022-01-01")
    closing_prices = data['Close']
    scaler = MinMaxScaler()
    scaled_data = scaler.fit_transform(closing_prices.values.reshape(-1, 1))

    # Prepare Data
    SEQ_LENGTH = 60
    x, y = create_sequences(scaled_data, SEQ_LENGTH)
    split = int(0.8 * len(x))
    x_train, x_val = x[:split], x[split:]
    y_train, y_val = y[:split], y[split:]

    # Build Model
    model = Sequential()
    model.add(LSTM(50, return_sequences=True, input_shape=(SEQ_LENGTH, 1)))
    model.add(Dropout(0.2))
    model.add(LSTM(50, return_sequences=False))
    model.add(Dense(25))
    model.add(Dense(1))
    model.compile(optimizer='adam', loss='mean_squared_error')

    # Train Model
    history = model.fit(x_train, y_train, validation_data=(x_val, y_val), batch_size=32, epochs=50)

    # Evaluate Model
    test_data = yf.download(stock_ticker, start="2022-01-01", end="2024-01-01")
    scaled_test_data = scaler.transform(test_data['Close'].values.reshape(-1, 1))
    x_test, y_test = create_sequences(scaled_test_data, SEQ_LENGTH)

    predictions = model.predict(x_test)
    predictions = scaler.inverse_transform(predictions)

    # Calculate error metrics
    mae = mean_absolute_error(y_test, predictions)
    mse = mean_squared_error(y_test, predictions)
    rmse = math.sqrt(mse)

    print(f"{stock_ticker} - Mean Absolute Error (MAE): {mae}")
    print(f"{stock_ticker} - Mean Squared Error (MSE): {mse}")
    print(f"{stock_ticker} - Root Mean Squared Error (RMSE): {rmse}")

    # Plot training and validation loss
    plt.figure(figsize=(12, 6))
    plt.plot(history.history['loss'], label='Training Loss')
    plt.plot(history.history['val_loss'], label='Validation Loss')
    plt.legend()
    plt.title(f"Training and Validation Loss for {stock_ticker}")
    plt.xlabel("Epochs")
    plt.ylabel("Loss")
    plt.show()

    plt.figure(figsize=(12, 6))
    plt.plot(historical_data['Close'], label='Historical Prices', color='blue')
    forecast_dates = pd.date_range(start=test_data.index[SEQ_LENGTH], periods=len(predictions), freq='B')
    plt.plot(forecast_dates, predictions.flatten(), label='Predicted Prices', color='red')
    plt.legend()
    plt.title(f"{stock_ticker} Full Stock Price Prediction with LSTM")
    plt.xlabel("Date")
    plt.ylabel("Price")
    plt.show()

    # Plot actual vs predicted prices
    plt.figure(figsize=(12, 6))
    plt.plot(test_data.index[SEQ_LENGTH:], test_data['Close'][SEQ_LENGTH:], label='Actual Prices')
    plt.plot(test_data.index[SEQ_LENGTH:], predictions, label='Predicted Prices')
    plt.legend()
    plt.title(f"{stock_ticker} Stock Price Prediction with LSTM")
    plt.xlabel("Date")
    plt.ylabel("Price")
    plt.show()

    # Calculate and print the average margin of difference
    avg_margin = average_margin_of_difference(test_data['Close'][SEQ_LENGTH:], predictions.flatten())
    avg_margin_percentage = average_margin_of_difference_percentage(test_data['Close'][SEQ_LENGTH:], predictions.flatten())
    direction_accuracy = directional_accuracy(test_data['Close'][SEQ_LENGTH:], predictions.flatten())

    print(f"Average margin of difference for {stock_ticker}: {avg_margin:.2f}")
    print(f"Average margin of difference for {stock_ticker} (percentage): {avg_margin_percentage:.2f}%")
    print(f"Directional accuracy for {stock_ticker}: {direction_accuracy:.2f}%")

# Helper function to create sequences
def create_sequences(data, seq_length):
    x = []
    y = []
    for i in range(seq_length, len(data)):
        x.append(data[i - seq_length:i])
        y.append(data[i])
    return np.array(x), np.array(y)

# Function to calculate the average margin of difference between actual and predicted prices
def average_margin_of_difference(actual, predicted):
    margins = actual.values - predicted
    avg_margin = np.mean(np.abs(margins))
    return avg_margin

# Function to calculate the average margin of difference as a percentage
def average_margin_of_difference_percentage(actual, predicted):
    margins = actual.values - predicted
    avg_margin_percentage = np.mean(np.abs(margins) / actual.values) * 100
    return avg_margin_percentage

# Function to calculate directional accuracy
def directional_accuracy(actual, predicted):
    actual_diff = np.sign(np.diff(actual.values, prepend=actual.values[0]))
    predicted_diff = np.sign(np.diff(predicted, prepend=predicted[0]))
    accuracy = np.mean(actual_diff == predicted_diff) * 100
    return accuracy

# Evaluate for multiple stocks
for ticker in ["GE", "CAT", "UNP"]:
    evaluate_lstm(ticker)

"""#### FB Prophet"""

# Commented out IPython magic to ensure Python compatibility.
# %%time
# from prophet import Prophet
# import yfinance as yf
# import pandas as pd
# import matplotlib.pyplot as plt
# 
# def run_prophet(ticker):
#     # Download data
#     data = yf.download(ticker, start="2010-01-01", end="2024-01-01")
#     df = pd.DataFrame(data['Close'])
#     df.reset_index(inplace=True)
#     df.rename(columns={'Date': 'ds', 'Close': 'y'}, inplace=True)
# 
#     # Fit the Prophet model on data up to the beginning of 2023
#     m = Prophet(daily_seasonality=False)
#     m.fit(df[df['ds'] < '2023-01-01'])  # Train only on data before 2023
# 
#     # Create future dataframe for forecasting
#     future = m.make_future_dataframe(periods=len(data['2023-01-01':]), freq='B')
#     forecast = m.predict(future)
# 
#     plt.figure(figsize=(12, 6))
#     plt.plot(df['ds'], df['y'], label='Historical Prices')
#     plt.plot(forecast['ds'], forecast['yhat'], color='red', label='Predicted Prices')
#     plt.title(f"{ticker} Stock Price Forecast with Prophet")
#     plt.xlabel("Date")
#     plt.ylabel("Price")
#     plt.legend()
#     plt.show()
#     # Plot historical and predicted prices
#     plt.figure(figsize=(12, 6))
#     plt.plot(df['ds'], df['y'], label='Historical Prices', color='blue')  # Historical prices
# 
#     # Only plot predicted prices starting from 2023
#     forecasted_data = forecast[forecast['ds'] >= '2022-01-01']
#     plt.plot(forecasted_data['ds'], forecasted_data['yhat'], color='red', label='Predicted Prices')  # Predicted prices
# 
#     plt.title(f"{ticker} Stock Price Forecast with Prophet")
#     plt.xlabel("Date")
#     plt.ylabel("Price")
#     plt.legend()
#     plt.show()
# 
#     plt.figure(figsize=(12, 6))
#     # Filter actual data for plotting
#     actual_data = df[df['ds'] >= '2022-01-01']
#     plt.plot(actual_data['ds'], actual_data['y'], label='Actual Prices', color='blue')
# 
#     # Filter forecast data for plotting
#     forecasted_data = forecast[forecast['ds'] >= '2022-01-01']
#     plt.plot(forecasted_data['ds'], forecasted_data['yhat'], label='Predicted Prices', color='orange')
# 
#     plt.title(f"{ticker} Stock Price Prediction with Prophet")
#     plt.xlabel("Date")
#     plt.ylabel("Price")
#     plt.legend()
#     plt.show()
# 
# run_prophet("GE")
# run_prophet("CAT")
# run_prophet("UNP")

# beginning of forecast is 2022
from prophet import Prophet
import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

def run_prophet(ticker):
    # Download data
    data = yf.download(ticker, start="2010-01-01", end="2024-01-01")
    df = pd.DataFrame(data['Close'])
    df.reset_index(inplace=True)
    df.rename(columns={'Date': 'ds', 'Close': 'y'}, inplace=True)

    # Fit the Prophet model on data up to the beginning of 2022
    m = Prophet(daily_seasonality=False)
    m.fit(df[df['ds'] < '2022-01-01'])  # Train only on data before 2022

    # Create future dataframe for forecasting
    future = m.make_future_dataframe(periods=len(data['2022-01-01':]), freq='B')
    forecast = m.predict(future)

    plt.figure(figsize=(12, 6))
    plt.plot(df['ds'], df['y'], label='Historical Prices')
    plt.plot(forecast['ds'], forecast['yhat'], color='red', label='Predicted Prices')
    plt.title(f"{ticker} Stock Price Forecast with Prophet")
    plt.xlabel("Date")
    plt.ylabel("Price")
    plt.legend()
    plt.show()

    # Plot historical and predicted prices
    plt.figure(figsize=(12, 6))
    plt.plot(df['ds'], df['y'], label='Historical Prices', color='blue')  # Historical prices

    # Only plot predicted prices starting from 2022
    forecasted_data = forecast[forecast['ds'] >= '2022-01-01']
    plt.plot(forecasted_data['ds'], forecasted_data['yhat'], color='red', label='Predicted Prices')  # Predicted prices

    plt.title(f"{ticker} Stock Price Forecast with Prophet")
    plt.xlabel("Date")
    plt.ylabel("Price")
    plt.legend()
    plt.show()

    plt.figure(figsize=(12, 6))
    # Filter actual data for plotting
    actual_data = df[df['ds'] >= '2022-01-01']
    plt.plot(actual_data['ds'], actual_data['y'], label='Actual Prices', color='blue')

    # Filter forecast data for plotting
    forecasted_data = forecast[forecast['ds'] >= '2022-01-01']
    plt.plot(forecasted_data['ds'], forecasted_data['yhat'], label='Predicted Prices', color='orange')

    plt.title(f"{ticker} Stock Price Prediction with Prophet")
    plt.xlabel("Date")
    plt.ylabel("Price")
    plt.legend()
    plt.show()

    # Calculate and print the average margin of difference
    avg_margin = average_margin_of_difference(actual_data['y'], forecasted_data['yhat'])
    avg_margin_percentage = average_margin_of_difference_percentage(actual_data['y'], forecasted_data['yhat'])
    direction_accuracy = directional_accuracy(actual_data['y'], forecasted_data['yhat'])

    print(f"Average margin of difference for {ticker}: {avg_margin:.2f}")
    print(f"Average margin of difference for {ticker} (percentage): {avg_margin_percentage:.2f}%")
    print(f"Directional accuracy for {ticker}: {direction_accuracy:.2f}%")

# Function to calculate the average margin of difference between actual and predicted prices
def average_margin_of_difference(actual, predicted):
    margins = actual.values - predicted.values
    avg_margin = np.mean(np.abs(margins))
    return avg_margin

# Function to calculate the average margin of difference as a percentage
def average_margin_of_difference_percentage(actual, predicted):
    margins = actual.values - predicted.values
    avg_margin_percentage = np.mean(np.abs(margins) / actual.values) * 100
    return avg_margin_percentage

# Function to calculate directional accuracy
def directional_accuracy(actual, predicted):
    actual_diff = np.sign(np.diff(actual.values, prepend=actual.values[0]))
    predicted_diff = np.sign(np.diff(predicted.values, prepend=predicted.values[0]))
    accuracy = np.mean(actual_diff == predicted_diff) * 100
    return accuracy

# Run the Prophet model for multiple stocks
run_prophet("GE")
run_prophet("CAT")
run_prophet("UNP")

"""### Baseline Sector - Indices Models

#### ARIMA
"""

import yfinance as yf
import pandas as pd
from statsmodels.tsa.arima.model import ARIMA
import matplotlib.pyplot as plt
import numpy as np

# Function to create a differenced series to make the data stationary
def difference(dataset, interval=1):
    diff = list()
    for i in range(interval, len(dataset)):
        value = dataset[i] - dataset[i - interval]
        diff.append(value)
    return np.array(diff)

# Function to invert differenced value
def inverse_difference(history, yhat, interval=1):
    return yhat + history[-interval]

# List of stock symbols to process
symbols = ["^GSPC", "^DJI", "^IXIC", "^RUT"]

for symbol in symbols:
    # Download historical data for each stock
    historical_data = yf.download(symbol, start="2010-01-01", end="2024-01-01")
    historical_data1 = yf.download(symbol, start="2022-01-01", end="2024-01-01")
    data = yf.download(symbol, start="2010-01-01", end="2022-01-01")
    close_prices = data['Close'].values

    # Assuming yearly differencing might be needed
    days_in_year = 365
    differenced = difference(close_prices, days_in_year)

    # Fit ARIMA model on the differenced data
    model = ARIMA(differenced, order=(1,1,1))
    model_fit = model.fit()

    # Forecast for the next two years (2022 to 2024)
    forecast = model_fit.forecast(steps=2*365)  # daily data

    # Invert the differenced forecast to something usable
    history = list(close_prices)
    predictions = []
    day = 1
    for yhat in forecast:
        inverted = inverse_difference(history, yhat, days_in_year)
        predictions.append(inverted)
        history.append(inverted)
        day += 1

    # Plotting the results
    plt.figure(figsize=(12, 6))
    plt.plot(historical_data.index, historical_data['Close'], label='Historical Closing Prices')
    forecast_index = pd.date_range(start='2022-01-01', periods=2*365, freq='D')
    plt.plot(forecast_index, predictions, color='red', label='Forecasted Closing Prices')
    plt.title(f'ARIMA Forecast of Future Stock Prices - {symbol}')
    plt.xlabel('Date')
    plt.ylabel('Stock Price')
    plt.legend()
    plt.show()

    plt.figure(figsize=(12, 6))
    plt.plot(historical_data1.index, historical_data1['Close'], label='Historical Closing Prices', color = 'blue')
    forecast_index = pd.date_range(start='2022-01-01', periods=2*365, freq='D')
    plt.plot(forecast_index, predictions, color='orange', label='Forecasted Closing Prices')
    plt.title(f'ARIMA Forecast of Future Stock Prices - {symbol}')
    plt.xlabel('Date')
    plt.ylabel('Stock Price')
    plt.legend()
    plt.show()

import yfinance as yf
import pandas as pd
from statsmodels.tsa.arima.model import ARIMA
import matplotlib.pyplot as plt
import numpy as np

# Function to create a differenced series to make the data stationary
def difference(dataset, interval=1):
    diff = list()
    for i in range(interval, len(dataset)):
        value = dataset[i] - dataset[i - interval]
        diff.append(value)
    return np.array(diff)

# Function to invert differenced value
def inverse_difference(history, yhat, interval=1):
    return yhat + history[-interval]

# Function to calculate the average margin of difference between actual and predicted prices
def average_margin_of_difference(actual, predicted):
    margins = actual.values - predicted
    avg_margin = np.mean(np.abs(margins))
    return avg_margin

# Function to calculate the average margin of difference as a percentage
def average_margin_of_difference_percentage(actual, predicted):
    margins = actual.values - predicted
    avg_margin_percentage = np.mean(np.abs(margins) / actual.values) * 100
    return avg_margin_percentage

# Function to calculate directional accuracy
def directional_accuracy(actual, predicted):
    actual_diff = np.sign(np.diff(actual.values, prepend=actual.values[0]))
    predicted_diff = np.sign(np.diff(predicted, prepend=predicted[0]))
    accuracy = np.mean(actual_diff == predicted_diff) * 100
    return accuracy

# List of tickers
tickers = ["^GSPC", "^DJI", "^IXIC", "^RUT"]

# Loop through each ticker
for ticker in tickers:
    # Download historical data for each ticker
    historical_data = yf.download(ticker, start="2010-01-01", end="2024-01-01")
    data = yf.download(ticker, start="2010-01-01", end="2022-01-01")
    close_prices = data['Close'].values

    # Assuming yearly differencing might be needed
    days_in_year = 365
    differenced = difference(close_prices, days_in_year)

    # Fit ARIMA model on the differenced data
    model = ARIMA(differenced, order=(1,1,1))
    model_fit = model.fit()

    # Forecast for the next two years (2022 to 2024)
    forecast = model_fit.forecast(steps=2*365)  # daily data

    # Invert the differenced forecast to something usable
    history = list(close_prices)
    predictions = []
    day = 1
    for yhat in forecast:
        inverted = inverse_difference(history, yhat, days_in_year)
        predictions.append(inverted)
        history.append(inverted)
        day += 1

    # Plotting the results for historical closing prices and forecasts
    plt.figure(figsize=(12, 6))
    plt.plot(historical_data.index, historical_data['Close'], label='Historical Closing Prices')
    forecast_index = pd.date_range(start='2022-01-01', periods=730, freq='D')
    plt.plot(forecast_index, predictions, color='red', label='Forecasted Closing Prices')
    plt.title(f'{ticker} ARIMA Forecast of Future Stock Prices')
    plt.xlabel('Date')
    plt.ylabel('Stock Price')
    plt.legend()
    plt.show()

    # Plotting actual prices and predicted prices
    plt.figure(figsize=(12, 6))
    plt.plot(historical_data.loc['2022-01-01':].index, historical_data.loc['2022-01-01':]['Close'], label='Actual Prices', color='blue')
    plt.plot(forecast_index, predictions, label='Predicted Prices', color='orange')
    plt.legend()
    plt.title(f"{ticker} Stock Price Prediction with ARIMA")
    plt.xlabel("Date")
    plt.ylabel("Price")
    plt.show()

    # Calculate and print the average margin of difference
    actual_prices = historical_data.loc['2022-01-01':]['Close']
    predicted_prices = pd.Series(predictions, index=forecast_index)
    avg_margin = average_margin_of_difference(actual_prices, predicted_prices[:len(actual_prices)])
    avg_margin_percentage = average_margin_of_difference_percentage(actual_prices, predicted_prices[:len(actual_prices)])
    direction_accuracy = directional_accuracy(actual_prices, predicted_prices[:len(actual_prices)])

    print(f"\nAverage margin of difference for {ticker}: {avg_margin:.2f}")
    print(f"Average margin of difference for {ticker} (percentage): {avg_margin_percentage:.2f}%")
    print(f"Directional accuracy for {ticker}: {direction_accuracy:.2f}%")

"""#### LSTM"""

# Commented out IPython magic to ensure Python compatibility.
# %%time
# def evaluate_lstm(stock_ticker):
#     print(f"Evaluating {stock_ticker}")
# 
#     # Fetch Data
#     historical_data = yf.download(stock_ticker, start="2010-01-01", end="2024-01-01")
#     data = yf.download(stock_ticker, start="2010-01-01", end="2022-01-01")
#     closing_prices = data['Close']
#     scaler = MinMaxScaler()
#     scaled_data = scaler.fit_transform(closing_prices.values.reshape(-1, 1))
# 
#     # Prepare Data
#     SEQ_LENGTH = 60
#     x, y = create_sequences(scaled_data, SEQ_LENGTH)
#     split = int(0.8 * len(x))
#     x_train, x_val = x[:split], x[split:]
#     y_train, y_val = y[:split], y[split:]
# 
#     # Build Model
#     model = Sequential()
#     model.add(LSTM(50, return_sequences=True, input_shape=(SEQ_LENGTH, 1)))
#     model.add(Dropout(0.2))
#     model.add(LSTM(50, return_sequences=False))
#     model.add(Dense(25))
#     model.add(Dense(1))
#     model.compile(optimizer='adam', loss='mean_squared_error')
# 
#     # Train Model
#     history = model.fit(x_train, y_train, validation_data=(x_val, y_val), batch_size=32, epochs=50)
# 
#     # Evaluate Model
#     test_data = yf.download(stock_ticker, start="2022-01-01", end="2024-01-01")
#     scaled_test_data = scaler.transform(test_data['Close'].values.reshape(-1, 1))
#     x_test, y_test = create_sequences(scaled_test_data, SEQ_LENGTH)
# 
#     predictions = model.predict(x_test)
#     predictions = scaler.inverse_transform(predictions)
# 
#     # Calculate error metrics
#     mae = mean_absolute_error(y_test, predictions)
#     mse = mean_squared_error(y_test, predictions)
#     rmse = math.sqrt(mse)
# 
#     print(f"{stock_ticker} - Mean Absolute Error (MAE): {mae}")
#     print(f"{stock_ticker} - Mean Squared Error (MSE): {mse}")
#     print(f"{stock_ticker} - Root Mean Squared Error (RMSE): {rmse}")
# 
#     # Plot training and validation loss
#     plt.figure(figsize=(12, 6))
#     plt.plot(history.history['loss'], label='Training Loss')
#     plt.plot(history.history['val_loss'], label='Validation Loss')
#     plt.legend()
#     plt.title(f"Training and Validation Loss for {stock_ticker}")
#     plt.xlabel("Epochs")
#     plt.ylabel("Loss")
#     plt.show()
# 
#     plt.figure(figsize=(12, 6))
#     plt.plot(historical_data['Close'], label='Historical Prices', color='blue')
#     forecast_dates = pd.date_range(start=test_data.index[SEQ_LENGTH], periods=len(predictions), freq='B')
#     plt.plot(forecast_dates, predictions.flatten(), label='Predicted Prices', color='red')
#     plt.legend()
#     plt.title(f"{stock_ticker} Full Stock Price Prediction with LSTM")
#     plt.xlabel("Date")
#     plt.ylabel("Price")
#     plt.show()
# 
#     # Plot actual vs predicted prices
#     plt.figure(figsize=(12, 6))
#     plt.plot(test_data.index[SEQ_LENGTH:], test_data['Close'][SEQ_LENGTH:], label='Actual Prices')
#     plt.plot(test_data.index[SEQ_LENGTH:], predictions, label='Predicted Prices')
#     plt.legend()
#     plt.title(f"{stock_ticker} Stock Price Prediction with LSTM")
#     plt.xlabel("Date")
#     plt.ylabel("Price")
#     plt.show()
# 
# 
# # Helper function to create sequences
# def create_sequences(data, seq_length):
#     x = []
#     y = []
#     for i in range(seq_length, len(data)):
#         x.append(data[i - seq_length:i])
#         y.append(data[i])
#     return np.array(x), np.array(y)
# 
# 
# # Evaluate for multiple stocks
# for ticker in ["^GSPC", "^DJI", "^IXIC", "^RUT"]:
#     evaluate_lstm(ticker)

# Import Libraries
import yfinance as yf
import pandas as pd
import numpy as np
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
from sklearn.metrics import mean_absolute_error, mean_squared_error
import matplotlib.pyplot as plt
import math

# Function to create LSTM model and evaluate it
def evaluate_lstm(stock_ticker):
    print(f"Evaluating {stock_ticker}")

    # Fetch Data
    historical_data = yf.download(stock_ticker, start="2010-01-01", end="2024-01-01")
    data = yf.download(stock_ticker, start="2010-01-01", end="2022-01-01")
    closing_prices = data['Close']
    scaler = MinMaxScaler()
    scaled_data = scaler.fit_transform(closing_prices.values.reshape(-1, 1))

    # Prepare Data
    SEQ_LENGTH = 60
    x, y = create_sequences(scaled_data, SEQ_LENGTH)
    split = int(0.8 * len(x))
    x_train, x_val = x[:split], x[split:]
    y_train, y_val = y[:split], y[split:]

    # Build Model
    model = Sequential()
    model.add(LSTM(50, return_sequences=True, input_shape=(SEQ_LENGTH, 1)))
    model.add(Dropout(0.2))
    model.add(LSTM(50, return_sequences=False))
    model.add(Dense(25))
    model.add(Dense(1))
    model.compile(optimizer='adam', loss='mean_squared_error')

    # Train Model
    history = model.fit(x_train, y_train, validation_data=(x_val, y_val), batch_size=32, epochs=50)

    # Evaluate Model
    test_data = yf.download(stock_ticker, start="2022-01-01", end="2024-01-01")
    scaled_test_data = scaler.transform(test_data['Close'].values.reshape(-1, 1))
    x_test, y_test = create_sequences(scaled_test_data, SEQ_LENGTH)

    predictions = model.predict(x_test)
    predictions = scaler.inverse_transform(predictions)

    # Calculate error metrics
    mae = mean_absolute_error(y_test, predictions)
    mse = mean_squared_error(y_test, predictions)
    rmse = math.sqrt(mse)

    print(f"{stock_ticker} - Mean Absolute Error (MAE): {mae}")
    print(f"{stock_ticker} - Mean Squared Error (MSE): {mse}")
    print(f"{stock_ticker} - Root Mean Squared Error (RMSE): {rmse}")

    # Plot training and validation loss
    plt.figure(figsize=(12, 6))
    plt.plot(history.history['loss'], label='Training Loss')
    plt.plot(history.history['val_loss'], label='Validation Loss')
    plt.legend()
    plt.title(f"Training and Validation Loss for {stock_ticker}")
    plt.xlabel("Epochs")
    plt.ylabel("Loss")
    plt.show()

    plt.figure(figsize=(12, 6))
    plt.plot(historical_data['Close'], label='Historical Prices', color='blue')
    forecast_dates = pd.date_range(start=test_data.index[SEQ_LENGTH], periods=len(predictions), freq='B')
    plt.plot(forecast_dates, predictions.flatten(), label='Predicted Prices', color='red')
    plt.legend()
    plt.title(f"{stock_ticker} Full Stock Price Prediction with LSTM")
    plt.xlabel("Date")
    plt.ylabel("Price")
    plt.show()

    # Plot actual vs predicted prices
    plt.figure(figsize=(12, 6))
    plt.plot(test_data.index[SEQ_LENGTH:], test_data['Close'][SEQ_LENGTH:], label='Actual Prices')
    plt.plot(test_data.index[SEQ_LENGTH:], predictions, label='Predicted Prices')
    plt.legend()
    plt.title(f"{stock_ticker} Stock Price Prediction with LSTM")
    plt.xlabel("Date")
    plt.ylabel("Price")
    plt.show()

    # Calculate and print the average margin of difference
    avg_margin = average_margin_of_difference(test_data['Close'][SEQ_LENGTH:], predictions.flatten())
    avg_margin_percentage = average_margin_of_difference_percentage(test_data['Close'][SEQ_LENGTH:], predictions.flatten())
    direction_accuracy = directional_accuracy(test_data['Close'][SEQ_LENGTH:], predictions.flatten())

    print(f"Average margin of difference for {stock_ticker}: {avg_margin:.2f}")
    print(f"Average margin of difference for {stock_ticker} (percentage): {avg_margin_percentage:.2f}%")
    print(f"Directional accuracy for {stock_ticker}: {direction_accuracy:.2f}%")

# Helper function to create sequences
def create_sequences(data, seq_length):
    x = []
    y = []
    for i in range(seq_length, len(data)):
        x.append(data[i - seq_length:i])
        y.append(data[i])
    return np.array(x), np.array(y)

# Function to calculate the average margin of difference between actual and predicted prices
def average_margin_of_difference(actual, predicted):
    margins = actual.values - predicted
    avg_margin = np.mean(np.abs(margins))
    return avg_margin

# Function to calculate the average margin of difference as a percentage
def average_margin_of_difference_percentage(actual, predicted):
    margins = actual.values - predicted
    avg_margin_percentage = np.mean(np.abs(margins) / actual.values) * 100
    return avg_margin_percentage

# Function to calculate directional accuracy
def directional_accuracy(actual, predicted):
    actual_diff = np.sign(np.diff(actual.values, prepend=actual.values[0]))
    predicted_diff = np.sign(np.diff(predicted, prepend=predicted[0]))
    accuracy = np.mean(actual_diff == predicted_diff) * 100
    return accuracy

# Evaluate for multiple stocks
for ticker in ["^GSPC", "^DJI", "^IXIC", "^RUT"]:
    evaluate_lstm(ticker)

"""#### FB Prophet"""

# Commented out IPython magic to ensure Python compatibility.
# %%time
# from prophet import Prophet
# import yfinance as yf
# import pandas as pd
# import matplotlib.pyplot as plt
# 
# def run_prophet(ticker):
#     # Download data
#     data = yf.download(ticker, start="2010-01-01", end="2024-01-01")
#     df = pd.DataFrame(data['Close'])
#     df.reset_index(inplace=True)
#     df.rename(columns={'Date': 'ds', 'Close': 'y'}, inplace=True)
# 
#     # Fit the Prophet model on data up to the beginning of 2023
#     m = Prophet(daily_seasonality=False)
#     m.fit(df[df['ds'] < '2022-01-01'])  # Train only on data before 2023
# 
#     # Create future dataframe for forecasting
#     future = m.make_future_dataframe(periods=len(data['2022-01-01':]), freq='B')
#     forecast = m.predict(future)
# 
#     plt.figure(figsize=(12, 6))
#     plt.plot(df['ds'], df['y'], label='Historical Prices')
#     plt.plot(forecast['ds'], forecast['yhat'], color='red', label='Predicted Prices')
#     plt.title(f"{ticker} Stock Price Forecast with Prophet")
#     plt.xlabel("Date")
#     plt.ylabel("Price")
#     plt.legend()
#     plt.show()
#     # Plot historical and predicted prices
#     plt.figure(figsize=(12, 6))
#     plt.plot(df['ds'], df['y'], label='Historical Prices', color='blue')  # Historical prices
# 
#     # Only plot predicted prices starting from 2023
#     forecasted_data = forecast[forecast['ds'] >= '2022-01-01']
#     plt.plot(forecasted_data['ds'], forecasted_data['yhat'], color='red', label='Predicted Prices')  # Predicted prices
# 
#     plt.title(f"{ticker} Stock Price Forecast with Prophet")
#     plt.xlabel("Date")
#     plt.ylabel("Price")
#     plt.legend()
#     plt.show()
# 
#     plt.figure(figsize=(12, 6))
#     # Filter actual data for plotting
#     actual_data = df[df['ds'] >= '2022-01-01']
#     plt.plot(actual_data['ds'], actual_data['y'], label='Actual Prices', color='blue')
# 
#     # Filter forecast data for plotting
#     forecasted_data = forecast[forecast['ds'] >= '2022-01-01']
#     plt.plot(forecasted_data['ds'], forecasted_data['yhat'], label='Predicted Prices', color='orange')
# 
#     plt.title(f"{ticker} Stock Price Prediction with Prophet")
#     plt.xlabel("Date")
#     plt.ylabel("Price")
#     plt.legend()
#     plt.show()
# 
# run_prophet("^GSPC")
# run_prophet("^DJI")
# run_prophet("^IXIC")
# run_prophet("^RUT")
#

# beginning of forecast is 2022
from prophet import Prophet
import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

def run_prophet(ticker):
    # Download data
    data = yf.download(ticker, start="2010-01-01", end="2024-01-01")
    df = pd.DataFrame(data['Close'])
    df.reset_index(inplace=True)
    df.rename(columns={'Date': 'ds', 'Close': 'y'}, inplace=True)

    # Fit the Prophet model on data up to the beginning of 2022
    m = Prophet(daily_seasonality=False)
    m.fit(df[df['ds'] < '2023-01-01'])  # Train only on data before 2022

    # Create future dataframe for forecasting
    future = m.make_future_dataframe(periods=len(data['2023-01-01':]), freq='B')
    forecast = m.predict(future)

    plt.figure(figsize=(12, 6))
    plt.plot(df['ds'], df['y'], label='Historical Prices')
    plt.plot(forecast['ds'], forecast['yhat'], color='red', label='Predicted Prices')
    plt.title(f"{ticker} Stock Price Forecast with Prophet")
    plt.xlabel("Date")
    plt.ylabel("Price")
    plt.legend()
    plt.show()

    # Plot historical and predicted prices
    plt.figure(figsize=(12, 6))
    plt.plot(df['ds'], df['y'], label='Historical Prices', color='blue')  # Historical prices

    # Only plot predicted prices starting from 2022
    forecasted_data = forecast[forecast['ds'] >= '2022-01-01']
    plt.plot(forecasted_data['ds'], forecasted_data['yhat'], color='red', label='Predicted Prices')  # Predicted prices

    plt.title(f"{ticker} Stock Price Forecast with Prophet")
    plt.xlabel("Date")
    plt.ylabel("Price")
    plt.legend()
    plt.show()

    plt.figure(figsize=(12, 6))
    # Filter actual data for plotting
    actual_data = df[df['ds'] >= '2023-01-01']
    plt.plot(actual_data['ds'], actual_data['y'], label='Actual Prices', color='blue')

    # Filter forecast data for plotting
    forecasted_data = forecast[forecast['ds'] >= '2022-01-01']
    plt.plot(forecasted_data['ds'], forecasted_data['yhat'], label='Predicted Prices', color='orange')

    plt.title(f"{ticker} Stock Price Prediction with Prophet")
    plt.xlabel("Date")
    plt.ylabel("Price")
    plt.legend()
    plt.show()

    # Calculate and print the average margin of difference
    avg_margin = average_margin_of_difference(actual_data['y'], forecasted_data['yhat'])
    avg_margin_percentage = average_margin_of_difference_percentage(actual_data['y'], forecasted_data['yhat'])
    direction_accuracy = directional_accuracy(actual_data['y'], forecasted_data['yhat'])

    print(f"Average margin of difference for {ticker}: {avg_margin:.2f}")
    print(f"Average margin of difference for {ticker} (percentage): {avg_margin_percentage:.2f}%")
    print(f"Directional accuracy for {ticker}: {direction_accuracy:.2f}%")

# Function to calculate the average margin of difference between actual and predicted prices
def average_margin_of_difference(actual, predicted):
    margins = actual.values - predicted.values
    avg_margin = np.mean(np.abs(margins))
    return avg_margin

# Function to calculate the average margin of difference as a percentage
def average_margin_of_difference_percentage(actual, predicted):
    margins = actual.values - predicted.values
    avg_margin_percentage = np.mean(np.abs(margins) / actual.values) * 100
    return avg_margin_percentage

# Function to calculate directional accuracy
def directional_accuracy(actual, predicted):
    actual_diff = np.sign(np.diff(actual.values, prepend=actual.values[0]))
    predicted_diff = np.sign(np.diff(predicted.values, prepend=predicted.values[0]))
    accuracy = np.mean(actual_diff == predicted_diff) * 100
    return accuracy

# Run the Prophet model for multiple stocks
run_prophet("^GSPC")
run_prophet("^DJI")
run_prophet("^IXIC")
run_prophet("^RUT")

